// -------------------------------------------------------------
// 
// File Name: D:\КЕОА\3 курс\Апараткі\Лаба №2\Lab2_2\Lab2_2\CALC_MAGNITUDE_AND_PHASE_FLOAT_POINT.v
// Created: 2023-01-24 21:01:12
// 
// Generated by MATLAB 9.12 and HDL Coder 3.20
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 1
// Target subsystem base rate: 1
// 
// 
// Clock Enable  Sample Time
// -- -------------------------------------------------------------
// ce_out        1
// -- -------------------------------------------------------------
// 
// 
// Output Signal                 Clock Enable  Sample Time
// -- -------------------------------------------------------------
// O_MAGNITUDE                   ce_out        1
// O_PHASE                       ce_out        1
// -- -------------------------------------------------------------
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: CALC_MAGNITUDE_AND_PHASE_FLOAT_POINT
// Source Path: Lab2_2/CALC_MAGNITUDE_AND_PHASE_FLOAT_POINT
// Hierarchy Level: 0
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module CALC_MAGNITUDE_AND_PHASE_FLOAT_POINT
          (clk,
           reset,
           clk_enable,
           I_COMPLEX_VALUE_re,
           I_COMPLEX_VALUE_im,
           ce_out,
           O_MAGNITUDE,
           O_PHASE);


  input   clk;
  input   reset;
  input   clk_enable;
  input   [31:0] I_COMPLEX_VALUE_re;  // single
  input   [31:0] I_COMPLEX_VALUE_im;  // single
  output  ce_out;
  output  [31:0] O_MAGNITUDE;  // single
  output  [31:0] O_PHASE;  // single


  wire enb;
  wire [31:0] Product_out1;  // ufix32
  wire [31:0] Product1_out1;  // ufix32
  wire [31:0] Add_out1;  // ufix32
  wire [31:0] Sqrt_out1;  // ufix32
  wire [31:0] Atan2_out1;  // ufix32
  reg [31:0] delayMatch_reg [0:4];  // ufix32 [5]
  wire [31:0] delayMatch_reg_next [0:4];  // ufix32 [5]
  wire [31:0] Atan2_out1_1;  // ufix32


  nfp_mul_single u_nfp_mul_comp (.clk(clk),
                                 .reset(reset),
                                 .enb(clk_enable),
                                 .nfp_in1(I_COMPLEX_VALUE_re),  // single
                                 .nfp_in2(I_COMPLEX_VALUE_re),  // single
                                 .nfp_out(Product_out1)  // single
                                 );

  nfp_mul_single u_nfp_mul_comp_1 (.clk(clk),
                                   .reset(reset),
                                   .enb(clk_enable),
                                   .nfp_in1(I_COMPLEX_VALUE_im),  // single
                                   .nfp_in2(I_COMPLEX_VALUE_im),  // single
                                   .nfp_out(Product1_out1)  // single
                                   );

  nfp_add_single u_nfp_add_comp (.clk(clk),
                                 .reset(reset),
                                 .enb(clk_enable),
                                 .nfp_in1(Product_out1),  // single
                                 .nfp_in2(Product1_out1),  // single
                                 .nfp_out(Add_out1)  // single
                                 );

  nfp_sqrt_single u_nfp_sqrt_comp (.clk(clk),
                                   .reset(reset),
                                   .enb(clk_enable),
                                   .nfp_in(Add_out1),  // single
                                   .nfp_out(Sqrt_out1)  // single
                                   );

  nfp_atan2_single u_nfp_atan2_comp (.clk(clk),
                                     .reset(reset),
                                     .enb(clk_enable),
                                     .nfp_in1(I_COMPLEX_VALUE_im),  // single
                                     .nfp_in2(I_COMPLEX_VALUE_re),  // single
                                     .nfp_out(Atan2_out1)  // single
                                     );

  assign enb = clk_enable;

  always @(posedge clk or posedge reset)
    begin : delayMatch_process
      if (reset == 1'b1) begin
        delayMatch_reg[0] <= 32'h00000000;
        delayMatch_reg[1] <= 32'h00000000;
        delayMatch_reg[2] <= 32'h00000000;
        delayMatch_reg[3] <= 32'h00000000;
        delayMatch_reg[4] <= 32'h00000000;
      end
      else begin
        if (enb) begin
          delayMatch_reg[0] <= delayMatch_reg_next[0];
          delayMatch_reg[1] <= delayMatch_reg_next[1];
          delayMatch_reg[2] <= delayMatch_reg_next[2];
          delayMatch_reg[3] <= delayMatch_reg_next[3];
          delayMatch_reg[4] <= delayMatch_reg_next[4];
        end
      end
    end

  assign Atan2_out1_1 = delayMatch_reg[4];
  assign delayMatch_reg_next[0] = Atan2_out1;
  assign delayMatch_reg_next[1] = delayMatch_reg[0];
  assign delayMatch_reg_next[2] = delayMatch_reg[1];
  assign delayMatch_reg_next[3] = delayMatch_reg[2];
  assign delayMatch_reg_next[4] = delayMatch_reg[3];



  assign ce_out = clk_enable;

  assign O_MAGNITUDE = Sqrt_out1;

  assign O_PHASE = Atan2_out1_1;

endmodule  // CALC_MAGNITUDE_AND_PHASE_FLOAT_POINT

